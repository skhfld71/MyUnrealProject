블루프린트 커뮤니케이션
-모든 블루프린트 커뮤니케이션은 단방향이다.

송신자(sender)와 수신자(receiver)로 나뉜다.
-송신자는 수신자로부터 return value를 구할 수 있다.
-쿼리도 날릴 수 있다.
-송신자가 수신자에 레퍼런스를 가지고 있다면, 직접 커뮤니케이션이나
블루프린트 인터페이스를 사용하고 있는 것입니다.
-수신자만이 송신자에 레퍼런스를 가질 수 있다면, 이벤트 디스패처를
사용하고 있는 것입니다.

3가지 주요 블루프린트 커뮤니케이션 방법
-직접 커뮤니케이션(Direct Communication)
 -송신자는 데이터와 변수를 쿼리할 수 있습니다.
 -데이터를 보내고 업데이트 할 수 있습니다.
 -송신자는 수신자의 기능을 호출할 수도 있습니다.
 -언제나 1대1(1-to-1) 커뮤니케이션이지 일대 다수가 될 수 없다.

-블루프린트 직접 커뮤니케이션은 다음을 알 때 사용된다.
 -보내는 오브젝트가 무엇인지 알 때
 -받는 오브젝트들이 무엇인지 알 때	
 -최소한 받는 오브젝트에 대해 레퍼런스를 받을 수 있는 분명한 방법이 있을 때
 -간단한 참과 거짓을 고르는 블루프린트에서는 사용하지 않는게 좋다.(예)문을 여시겠습니까? 예, 아니요)
 -레퍼런스를 구했다면, 송신자는 이레퍼런스를 자신이 커뮤니케이션 하고 싶은 것에 형변환해야할 수도 있다.
 -형변환은 그냥 커뮤니케이션하고자 하는 것을 테스트 및 검증하는 것이다.
 -형변환이 성공했다면, 연결이 완료되었으며, 커뮤니케이션 할 준비가 된 것이다. 송신자는 데이터를 보낼 수 있고
 수신자로부터 데이터를 받거나 쿼리할 수 있으며 수신자에 직접 기능을 호출할 수 있다.

-블루프린트 직접 커뮤니케이션에 대한 실제 활용
 -게임을 시작할 때 레퍼런스를 할당할 수 있다.(BeginPlay)
 -Overlap
 -Get All Object나 Get All Actor of Class 노드를 사용할 수도 있습니다.(대신 굉장히 느려질 것이다.)

 
-블루프린트 인터페이스 메세지 콜(Blueprint Interface  Message Calls)
-이벤트 디스패쳐(Event Dispatchers)


블루프린트의 형변환
-커뮤니케이션을 할 대상을 검증하는 수단
 -주어진 유형에 맞게 형변환을 했다면 그제서야 접근가능, 그 후에나
 커뮤니케이션이 된다.
 -대상에 요구할 수 있고, 커뮤니케이션할 수 있으며, 기능을 호출할 수 있다.
 -형변환에 실패했다면 다른 것에 형변환할 수 있다(어떤 액터나 오브젝트에 레퍼런스를 구하고 질문을 던져보는 것)
 -만약 중첩해서 판단할 것이 너무 많다면 커뮤니케이션 방식을 재고해 볼 필요가 있다.
 -이미 적절한 유형의 레퍼런스를 가지고 있다면, 형변환을 할 필요가 없다.  (예)이미 존재하는 걸 아는 문/ 레퍼런스를 변수에 담으면)

형변환과 객체지향(언리얼 엔진 자체가 객체 지향 프레임워크에 빌드되어서 객체 지향의 개념에 대해 알아야 할 필요가 있다.)
-기본적으로 Object->Actor->Pawn->Charater->wendy 의 계층구조를 가짐
 - 예를들어 wendy라는 캐릭터에 형변환을 하면 당신은 구체적으로 wendy와 관련된 것에 접근이 가능하다. 예) wendy의 바지 색깔
 -블루프린트의 일부로 wendy에 형변환을 하면 다른 캐릭터과 구체적으로 관련된 것들에는 접근을 할 수 없게 된다. 예) john의 윗옷 색깔, peter의 단검의 색
 -모든 포제서블 캐릭터가 이용 가능한 뭔가에 접근을 해야 한다면 계층 구조상 바로 다음 윗단계의 클래스에서 형변환을 해야 할 수도 있다. 
 (다같이 상속 받아야 하는 부분에는 한단계 위인 캐릭터에서 형변환을 함)
 -형변환 단계가 필요한 기능에 대한 접근을 제공해준다는 보장은 없다. 너무 상위 부모 클래스로 형변환을 하면 자식만이 가지고 있는 특정 기능에는  접근하지 못한다.
 - 상위 베이스 클래스를 공유한다는 개념과  반복 작업은 피하는 것을 기억해야 한다. 자손 클래스 간에 노드를 선택해 복사하고 있다면 잘못하고 있는 것이다.
 그냥 부모 클래스로 올라가서 그 기능을 부모한테 주면 자식이 알아서 상속을 한다.   

