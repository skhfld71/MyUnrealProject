블루프린트 커뮤니케이션
-모든 블루프린트 커뮤니케이션은 단방향이다.

송신자(sender)와 수신자(receiver)로 나뉜다.
-송신자는 수신자로부터 return value를 구할 수 있다.
-쿼리도 날릴 수 있다.
-송신자가 수신자에 레퍼런스를 가지고 있다면, 직접 커뮤니케이션이나
블루프린트 인터페이스를 사용하고 있는 것입니다.
-수신자만이 송신자에 레퍼런스를 가질 수 있다면, 이벤트 디스패처를
사용하고 있는 것입니다.

3가지 주요 블루프린트 커뮤니케이션 방법
@직접 커뮤니케이션(Direct Communication)
-직접 커뮤니케이션(Direct Communication)이란
 -송신자는 데이터와 변수를 쿼리할 수 있습니다.
 -데이터를 보내고 업데이트 할 수 있습니다.
 -송신자는 수신자의 기능을 호출할 수도 있습니다.
 -언제나 1대1(1-to-1) 커뮤니케이션이지 일대 다수가 될 수 없다.

-블루프린트 직접 커뮤니케이션은 다음을 알 때 사용된다.
 -보내는 오브젝트가 무엇인지 알 때
 -받는 오브젝트들이 무엇인지 알 때	
 -최소한 받는 오브젝트에 대해 레퍼런스를 받을 수 있는 분명한 방법이 있을 때
 -간단한 참과 거짓을 고르는 블루프린트에서는 사용하지 않는게 좋다.(예)문을 여시겠습니까? 예, 아니요)
 -레퍼런스를 구했다면, 송신자는 이레퍼런스를 자신이 커뮤니케이션 하고 싶은 것에 형변환해야할 수도 있다.
 -형변환은 그냥 커뮤니케이션하고자 하는 것을 테스트 및 검증하는 것이다.
 -형변환이 성공했다면, 연결이 완료되었으며, 커뮤니케이션 할 준비가 된 것이다. 송신자는 데이터를 보낼 수 있고
 수신자로부터 데이터를 받거나 쿼리할 수 있으며 수신자에 직접 기능을 호출할 수 있다.

-블루프린트 직접 커뮤니케이션에 대한 실제 활용
 -게임을 시작할 때 레퍼런스를 할당할 수 있다.(BeginPlay)
 -Overlap
 -Get All Object나 Get All Actor of Class 노드를 사용할 수도 있습니다.(대신 굉장히 느려질 것이다.)

 
@블루프린트 인터페이스 메세지 콜(Blueprint Interface  Message Calls)
-블루프린트 인터페이스란?
 -아무런 구현을 하지않고 기능을 명시할 수 있는 수단이다. 
 -뭔가에 신호를 보내고 싶고, 그 뭔가가 아무튼 아무 행동이나 하도록 만들고 싶다면 블루프린트 인터페	 이스를 사용하라!
 -블루프린트 인터페이스도 1대1 커뮤니케이션을 사용한다. (레퍼런스를 얻고 그 레퍼런스에 메세지를 보 내는 방식)
 -송신자는 여전히 수신자에게 레퍼런스를 보내줘야 하고, 그냥 공백 신호를 보내는게 아니라 초기 레퍼런 스를 구해줘야 한다. 왜냐하면 이 레퍼런스가 실제로 커뮤니케이션 하는 상대를 결정한다.

-블루프린트 인터페이스의 원리는 무엇일까?
 -블루프린트 인터페이스는 커뮤니케이션의 매우 독특한 형태이다.(자신만의 언리얼 에셋)
 -데이터를 보낸 후, 그 에셋을 통해 블루프린트 인터페이스 메세지를 호출해서 듣고 있던 어떤 오브젝트 에게든 전달할 수 있다.
 -기본설정으로 블루프린트 인터페이스의 메세지를 받는 것은 없고, 블루프린트 인터페이스를 빌드해 이것 을 통해 메세지를 보내도 기본 설정으로는 아무것도 그 메세지를 받지 않는다.
 -메세지를 받기 원하는 블루프린트에 이 블루프린트 인터페이스를 구현해야 한다. 그렇지 않으면 그 블루  프린트 인터페이스는 아무것도 하지 않습니다. (블루프린트 인터페이스는 일종의 전선이라 생각하면 된다 . 스위치와 전구사이의 둘을 이어주는 전선이 없으면 아무일도 일어나지 않는 것처럼 블루프린트 인터페 이스는 그 역할을 해준다.)
 -블루프린트 인터페이스 메세지에 응답할 필요가 없는 것에는 블루프린트 인터페이스를 구현할 필요가  없다. 
 - 제일 중요한 것은 블루프린트 인터페이스를 구현했는지, 그리고 구현을 제대로 했는지이다.

-블루프린트 인터페이스는 언제 사용하는가?
 -만약 오브젝트에 신호를 보내고 싶고, 오브젝트 역시 이 신호를 받고 자신이 뭘 해야 할지 안다.
 (상호작용 버튼을 누르면 문이 자신이 열려야된다는 것을 알고, 전등은 자신들이 켜져야 한다는 것을 안다
 -구현이란, 문이 열리든 전등이 켜지든 무슨 일이 벌어지든 간에 모두 수신자가 신경쓸 일이지 송신자가  신경을 쓸 일이 아니다.
 -블루프린트 인터페이스는 서브레벨 간의 커뮤니케이션에 사용될 수 있다.

-블루프린트 인터페이스의 기능
 -블루프린트 인터페이스는 일반적인 그래프가 아니라서 노드를 추가할 수 없다.
 -수신 클래스에 인터페이스를 구현(이 메세지를 받아야 하는 모든 클래스는 이 인터페이스를 구현해야 함
 -블루프린트 인터페이스를 구현하려면 메세지를 받는 클래스의 클래스 설정으로 가서 Implemented  Interfaces 에서 새로운 인터페이스를 추가하면된다.(작업이 끝난 후에는 반드시 재컴파일이 필요하다.    재컴파일을 할 때까지 이 블루프린트 인터페이스는 존재하지가 않는다.)
 -이게 끝나면 함수와 똑같은 이름을 가진 이벤트를 그래프 내에 만들 수 있다. 이 클래스가 블루프린트 인 터페이스 함수를 위한 메세지를 받는 경우, 그 반응으로 뭔가가 일어난다. 인터페이스를 실제로 구현해야  할 것은 오로지 수신자뿐이다. 송신자에는 구현을 신경쓸 필요가 없다. 누구나 인터페이스를 호출할 수 있  으니까 말이다.
 -월드 내에 모든 것은 인터페이스를 호출할 수 있다. 단지 인터페이스가 구현된 수신자만이 응답할 수 있  을 뿐이다.

-블루프린트 인터페이스의 재미있는 특성
 -retrun value를 가진 인터페이스 함수를 만든다면, 수신자에 함수로 구현이 된다. 반대로 return value가 
 없는 인터페이스 함수를 만든다면 이것은 이벤트로 구현이 된다.
 -밖으로 뭔가를 보내는 것이지, 그 결과로 뭔가 돌아오는 데는 신경쓰지 않는다.
 -인터페이스를 구성할 때 출력 값이 있다면 이벤트가 아닌 함수로 구현이 된다. 
 -스스로 호출하도록 인터페이스를 사용할 수 있다. 수신자에 인터페이스 함수를 구현하면, 본인이 원하기 만 한다면 같은 인터페이스가 스스로에게 메세지를 보내도록 수신자를 사용할 수 있다.

@이벤트 디스패쳐(Event Dispatchers)


블루프린트의 형변환
-커뮤니케이션을 할 대상을 검증하는 수단
 -주어진 유형에 맞게 형변환을 했다면 그제서야 접근가능, 그 후에나
 커뮤니케이션이 된다.
 -대상에 요구할 수 있고, 커뮤니케이션할 수 있으며, 기능을 호출할 수 있다.
 -형변환에 실패했다면 다른 것에 형변환할 수 있다(어떤 액터나 오브젝트에 레퍼런스를 구하고 질문을 던져보는 것)
 -만약 중첩해서 판단할 것이 너무 많다면 커뮤니케이션 방식을 재고해 볼 필요가 있다.
 -이미 적절한 유형의 레퍼런스를 가지고 있다면, 형변환을 할 필요가 없다.  (예)이미 존재하는 걸 아는 문/ 레퍼런스를 변수에 담으면)

형변환과 객체지향(언리얼 엔진 자체가 객체 지향 프레임워크에 빌드되어서 객체 지향의 개념에 대해 알아야 할 필요가 있다.)
-기본적으로 Object->Actor->Pawn->Charater->wendy 의 계층구조를 가짐
 - 예를들어 wendy라는 캐릭터에 형변환을 하면 당신은 구체적으로 wendy와 관련된 것에 접근이 가능하다. 예) wendy의 바지 색깔
 -블루프린트의 일부로 wendy에 형변환을 하면 다른 캐릭터과 구체적으로 관련된 것들에는 접근을 할 수 없게 된다. 예) john의 윗옷 색깔, peter의 단검의 색
 -모든 포제서블 캐릭터가 이용 가능한 뭔가에 접근을 해야 한다면 계층 구조상 바로 다음 윗단계의 클래스에서 형변환을 해야 할 수도 있다. 
 (다같이 상속 받아야 하는 부분에는 한단계 위인 캐릭터에서 형변환을 함)
 -형변환 단계가 필요한 기능에 대한 접근을 제공해준다는 보장은 없다. 너무 상위 부모 클래스로 형변환을 하면 자식만이 가지고 있는 특정 기능에는  접근하지 못한다.
 - 상위 베이스 클래스를 공유한다는 개념과  반복 작업은 피하는 것을 기억해야 한다. 자손 클래스 간에 노드를 선택해 복사하고 있다면 잘못하고 있는 것이다.
 그냥 부모 클래스로 올라가서 그 기능을 부모한테 주면 자식이 알아서 상속을 한다.   

